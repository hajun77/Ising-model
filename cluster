void LinkedList() {
    LinkList.clear();
    LegType.clear();
    Associates.clear();

    vector<int> First(nSpin);
    for (int i = 0; i < nSpin; ++i) {
        First[i] = LinkList.size();
        LinkList.push_back(-99);
        LegType.push_back(spin_left[i]);
        Associates.push_back(nullt);
    }

    vector<int> spin_prop = spin_left;

    for (int i = 0; i < 2 * M; ++i) {
        int op = operator_list[i][0];
        int s1 = operator_list[i][1];
        int s2 = (op >= 0) ? operator_list[i][1] : -1;

        if (op == -2 || op == -1) {
            // site operator
            int site = s1;
            LinkList.push_back(First[site]);
            LegType.push_back(spin_prop[site]);
            if (op == -2) spin_prop[site] ^= 1;
            int curr = LinkList.size() - 1;
            LinkList[First[site]] = curr;
            First[site] = curr + 1;
            Associates.push_back(nullt);

            LinkList.push_back(-99);
            LegType.push_back(spin_prop[site]);
            Associates.push_back(nullt);

        } else {
            // bond operator
            int site1 = op;
            int site2 = s1;
            int v_start = LinkList.size();

            LinkList.push_back(First[site1]);
            LegType.push_back(spin_prop[site1]);
            LinkList[First[site1]] = v_start;
            First[site1] = v_start + 2;
            Associates.push_back(make_tuple(v_start + 1, v_start + 2, v_start + 3));

            LinkList.push_back(First[site2]);
            LegType.push_back(spin_prop[site2]);
            LinkList[First[site2]] = v_start + 1;
            First[site2] = v_start + 3;
            Associates.push_back(make_tuple(v_start, v_start + 2, v_start + 3));

            LinkList.push_back(-99);
            LegType.push_back(spin_prop[site1]);
            Associates.push_back(make_tuple(v_start, v_start + 1, v_start + 3));

            LinkList.push_back(-99);
            LegType.push_back(spin_prop[site2]);
            Associates.push_back(make_tuple(v_start, v_start + 1, v_start + 2));
        }
    }

    for (int i = 0; i < nSpin; ++i) {
        LinkList.push_back(First[i]);
        LegType.push_back(spin_prop[i]);
        int curr = LinkList.size() - 1;
        LinkList[First[i]] = curr;
        Associates.push_back(nullt);
    }

    lsize = LinkList.size();

    if (spin_prop != spin_right) {
        cout << "Basis state propagation error: LINKED LIST" << endl;
    }
}

void ClusterUpdate() {
    vector<int> in_cluster(lsize, 0);
    vector<int> cstack;
    int ccount = 0;

    for (int i = 0; i < lsize; ++i) {
        if (in_cluster[i] == 0 && Associates[i] == nullt) {
            ccount++;
            cstack.push_back(i);
            in_cluster[i] = ccount;

            bool flip = rand() % 2;
            if (flip) LegType[i] ^= 1;

            while (!cstack.empty()) {
                int leg = LinkList[cstack.back()];
                cstack.pop_back();

                if (in_cluster[leg] == 0) {
                    in_cluster[leg] = ccount;
                    if (flip) LegType[leg] ^= 1;

                    auto assoc = Associates[leg];
                    if (assoc != nullt) {
                        for (int k = 0; k < 3; ++k) {
                            int a = get<k>(assoc);
                            cstack.push_back(a);
                            in_cluster[a] = ccount;
                            if (flip) LegType[a] ^= 1;
                        }
                    }
                }
            }
        }
    }

    int ocount = 0;
    for (int i = 0; i < nSpin; ++i) {
        spin_left[i] = LegType[i];
        ocount++;
    }

    ocount++;

    for (int i = 0; i < 2 * M; ++i) {
        if (operator_list[i][0] != -2 && operator_list[i][0] != -1) {
            ocount += 4;
        } else {
            if (LegType[ocount] == LegType[ocount + 1]) {
                operator_list[i][0] = -1;
            } else {
                operator_list[i][0] = -2;
            }
            ocount += 2;
        }
    }

    for (int i = 0; i < nSpin; ++i) {
        spin_right[i] = LegType[lsize - nSpin + i];
    }
}

